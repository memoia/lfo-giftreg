IMM4LFO 2011-09-17
Code Sample for SE Team


INSTALLATION

Hopefully you can just use './manage.py runserver' to try it out.
This is my environment:

python -V			  ==> Python 2.6.6
'.'.join(map(str,django.VERSION)) ==> '1.2.3.final.0'


COMMENTS

This project implements "Sample Project 2: The Gift Registry"
as defined in "Code Sample Guidelines.pdf" (trac: LFO Common, 
CodeSampleGuideLines) sent to me by Joanna Maulding on 2011-09-14 17:27CDT.
The primary "app" is "gr".

My intention is to learn how to use Django, its ORM, and unittest.

Design choices:

* Make use of Django's authentication system to keep track of users;
  extend the User structure to make distinction between user types
  for this particular app.

* Use the Event to enforce the singular relationship between Recipients
  and Events, so that Recipients can potentially have multiple Events 
  in future if we so decide. Keep gift list separate for same reason.

* Single app; gift registry as a whole could be used as a component in
  larger sites (say, an online store).

I have tried to follow the specification as closely as possible, however,
I think that it limits the usefulness of the app. For next time, I think
it might be nice to:

* Eliminate the distinction between user types, allowing users to be
  both recipients and attendees. Maybe consider an event "host"---a user 
  who "owns" an event, and therefore,

* Allow recipients to host more than one event. The spec seems to imply
  that a recipient may only have one event ever, which seriously reduces
  their greed potential. 

* Introduce models for Venue, Store, and Location. Event would relate
  to Venue, Gift would relate to Store, and Location would relate to both.
  Location might include attributes for mailing address and geocoordinates,
  allowing for quick map-drawing through a public API.


QUESTIONS

* What is the best way to split models and views up into separate
  files, without having to maintain from...import statements for
  each one in the __init__.py file? 

* Where is it best to place code that constrains how data can be used?
  As methods in a custom model manager? In the view that accesses them?
  In the model itself? (And how would that look for models that need to
  be tightly coupled?)

* Are there best practices for choosing field types, beyond minimal
  size? i.e., can I trust the ManyToMany type will work as efficiently
  as if I implemented it "manually" using just ForeignKey types?

* Is there a way to see the SQL generated by the ORM for various queries?






